Una idea para el caso de las arquitecturas viejas es que, para cada archivo de tamaño dinámico (como por ejemplo, uno con extensión ".php") que se cargó por última vez en memoria, se guarde un registro de la cantidad de páginas de RAM que gastó, tanto para código, como para datos y como para pila, de tal forma que la próxima vez que se vuelva a cargar, se reserve espacio para esa cantidad de páginas más una adicional por segmento. La página adicional se utilizaría como margen de cambio, en caso de que el espacio que se necesite haya crecido después de la última vez que se cargó.

Otra idea es que antes de cargar un archivo de tamaño estático (como por ejemplo, un archivo con extensión ".htm") o programa en memoria RAM, se sigan los siguientes tres pasos:

1. Primero se verifique si está en la caché de RAM, en cuyo caso se tomaría de allí.
2. Después se verificaría si está en el disco duro, en cuyo caso haría lo mismo.
3. Por último, si se carga desde otro lugar en Internet, se obtendría de allí.

Debido a esto, sería mejor guardar todo el código estático en archivos distintos, con el fin de que el proceso que los necesite, no tenga que volver a tomarlos desde su lugar de origen. (Por ejemplo, un proceso que tiene a su cargo una página web, podría aplicarle los estilos CSS más rápidamente, si estos ya se encuentran analizados en estructuras de datos de la memoria RAM). Así, si un fragmento de texto, corresponde por ejemplo a una noticia, se podría crear un archivo con nombre el número de identificación de la noticia y extensión ".htm". Así si no existe ese archivo se crearía y después se referenciaría dentro del código fuente del archivo ".php", (por ejemplo), que lo contiene.

Otra idea es que se divida la memoria RAM en dos pilas. En un extremo estaría la memoria del sistema operativo y en el otro extremo estaría la memoria de los procesos y archivos del usuario. Cuando un proceso o archivo del usuario se elimine, lo que se haría antes de liberar su espacio en memoria, sería copiarlo en la caché, la cual estaría en el área de memoria del sistema operativo. Así, si un proceso o archivo que se intenta cargar, se encuentra en la caché de RAM, simplemente se toma de allí, en vez de acudir a otras fuentes como el disco duro o un sitio web. La caché de RAM podría estar al final de la memoria del sistema operativo, con el fin de ampliarla y compactarla fácilmente.

Otra idea es que para cada proceso o archivo en caché de RAM, se guarde un contador y un reloj decreciente, de tal forma que cada vez que se acceda de nuevo (el proceso o archivo), se incremente en uno el contador y se reinicie el reloj (tal vez) en 5 minutos de tal forma que cuando ese reloj llegue a 0, se decremente el contador en uno. De esta forma, antes de eliminar un proceso o archivo de la caché, se revisaría si ese contador está en 0. Si no lo está, no se eliminaría de la caché. En caso contrario, sí se eliminaría. Una mejora de este algoritmo, es que cuando el contador llegue a 0, se registre la fecha y hora en que ocurrió esto, pero no se eliminaría el espacio del proceso o archivo en la caché. Así, cuando un proceso o archivo requiera memoria RAM para cargarse, pero no hay suficiente libre, esta se tomaría de la caché. El primer criterio que se seguiría es si hay algún proceso o archivo cuyo contador ya llegó a 0 y de ser así, cuál fue el más antiguo en registrar ese evento; ese espacio sería el que se tomaría. Si ningún contador ha llegado a 0, se tomaría el que tenga el valor más bajo y entre ellos, el que tenga el reloj más cerca de llegar a 0. Se tomaría espacio de la memoria caché mientras el proceso o archivo que lo solicite para cargarse en memoria RAM, requiera más. Otra mejora a este algoritmo es que el sistema operativo, antes de liberar la memoria caché RAM de un proceso, la copie en el disco duro (si queda espacio suficiente), de tal forma que si la misma aplicación se vuelve a cargar a memoria RAM, el sistema operativo la inicie con la caché en disco duro que tiene de ella.

Otra idea es que cada vez que se elimine un proceso o un archivo de la memoria caché de RAM, o bien, antes de asignar memoria a un nuevo proceso, se compacte toda la memoria RAM, antes de continuar con la ejecución de otro proceso. Así no se produce segmentación externa y la asignación de memoria a un nuevo proceso que se cargue a la RAM, sería trivial; simplemente después del último proceso o archivo cargado.

Otra idea es que si no hay suficiente espacio en memoria RAM para cargar una nueva aplicación, se revise cuál fue la menos recientemente usada, de tal forma que su memoria RAM se guardaría en disco, para asignársela a la nueva aplicación. (Esto se repetiría mientras la memoria RAM total libre no alcance para cargar la aplicación que se desea cargar). Para saber cuál fue la aplicación menos recientemente usada, el sistema operativo podría recurrir a los eventos del usuario (como el mouse y el teclado). Podría registrar en la memoria del sistema operativo, para cada aplicación cargada en memoria, cuál fue la fecha y hora en que recibió por última vez un evento del usuario. Luego si el usuario vuelve a cargar una aplicación cuya memoria RAM se guardó en disco, lo que se haría sería cargar esa memoria del disco.

Otra idea es que si por ejemplo, la aplicación es un navegador web, cuando pida memoria RAM para cargar otra página web, no libere la memoria RAM reservada para la página que se está visualizando, sino que la reutilice cuando vaya a cargar otra página web, en vez de pedirle más memoria RAM al sistema operativo, con el fin de cargarla allí. Una forma de implementar esto, es que cada vez que se le pida memoria RAM al sistema operativo, esta se guarde en una entrada de un arreglo de punteros (tal vez "void *"), de tal forma que cuando, por ejemplo, la aplicación vaya a pedir memoria para una determinada estructura, no se pida del sistema operativo, sino que se tome de una fracción de esas entradas. Además, en esa estructura se podría guardar el número de entrada de ese arreglo y el desplazamiento en esa entrada, de tal forma que cuando se vaya a liberar algo de memoria, se libere el fragmento correspondiente en la entrada del arreglo. Una forma en que se podría implementar el listado de espacios libres en la memoria de estructuras propias de la aplicación, es por medio de un árbol binario, de tal forma que los nodos en él, se encuentren ordenados por tamaño del espacio libre. El árbol binario se podría balancear cuando se haya hecho una determinada cantidad N de cambios a sus nodos, con N (tal vez) mayor o igual al 25% del número de nodos en el árbol, al momento de verificar N. Un navegador web podría tener un arreglo de las memoria ocupada por las últimas páginas web que ha cargado (tal vez unas 5), de tal forma que si no hay suficiente espacio en memoria para cargar la siguiente página web, verifique si hay suficiente espacio entre el ocupado por las últimas páginas web menos la última, en cuyo caso liberaría ese espacio ocupado, empezando desde la menos recientemente cargada en adelante y se lo asignaría a la página web que va a cargar. En caso de que ocurra esto, o bien, que no haya suficiente espacio entre las últimas páginas web cargadas, para asignárselo a la que va a cargar, le podría pedir al sistema operativo que le asigne al proceso (tal vez) un 150% del espacio que requiere dicha página web. Una mejora a este algoritmo, es que antes de liberarse el espacio en memoria RAM asignado a una página web, este se copie en el disco duro, de tal forma que antes de recargar una página desde la web, se verifique si está en la caché del disco duro, en cuyo caso se tomaría de allí, en vez de hacer la carga desde la web.

Otra idea es que por cada proceso o archivo en caché (de RAM o de disco), se podría registrar la fecha y hora de última modificación y quizás también, para asegurar, su tamaño en bits. Así, por ejemplo, antes de descargar un archivo (de tamaño estático) de Internet, se podría revisar si su fecha y hora de última modificación, así como su tamaño en bits coinciden con los que están registrados, en cuyo caso no se descargaría. Si no coinciden ambos datos, entonces se procedería a su descarga.

Otra idea es que se haga una compilación para arquitecturas nuevas y otra para viejas, de tal forma que se prueben las dos por aparte. Así se podría programar en una arquitectura nueva y compilar tanto para una nueva como para una vieja, lo cual reduce en mucho los tiempos de desarrollo y además le sirven a todos los clientes; inclusive a aquellos que tienen dispositivos viejos.

Otra idea es que, para acelerar la ejecución en dispositivos viejos, cada proceso tenga a su cargo el CPU durante un lapso corto de tiempo. Esto por si por ejemplo, cada proceso tiene el CPU durante 15 milisegundos y hay 20 procesos, cada uno de ellos tendría que esperar 300 milisegundos para volver a tomarlo, con lo cual, el usuario notaría la lentitud del sistema operativo. En cambio, si cada proceso tiene el CPU durante un milisegundo, con 20 procesos, tendría que esperar solo 20 milisegundos, por lo cual, el usuario no notaría mucho la lentitud de ejecución, pues se harían cambios sobre los datos, cada 20 milisegundos, en vez de cada 300 milisegundos. Si se considera que la pantalla se refresca unas 60 veces por segundo, eso significa que todos los procesos se deberían ejecutar cada 1000/60 milisegundos (que es igual a unos 16 milisegundos), para que el efecto no lo note el ojo humano. Se podría definir una cantidad mínima de tiempo que debería durar en ejecución un proceso, según la velocidad a la que puede ejecutar el hardware, considerando entre otros aspectos, los cambios de contexto.

Otra idea es que, con el fin de actualizar eficientemente el sistema operativo, el dispositivo descargue las nuevas versiones de los archivos de este en el disco duro, tal vez con otro nombre (que podría ser su nombre original y un sufijo de número de versión), de tal forma que cuando termine de hacer la descarga de un programa, ejecute un proceso que verificaría, tal vez por medio una tabla de una base de datos, los nuevos archivos, (para lo cual podría revisar su tamaño específico en bits, así como una suma de verificación). Una vez completado este procedimiento sobre un mismo programa, se recompilaría, se descargaría la versión anterior de la memoria RAM y se recargaría la nueva versión. Posteriormente se eliminarían las versiones anteriores de los archivos sustituidos del disco duro (que podrían estar en otra tabla de la base de datos).
